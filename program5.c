/////////////////////////////////////////////////////////////////////////////////////////////////////////
// program5.c
// Author: Raisaat Atifa Rashid
//
// Procedures:
//      main				Runs 100 simulations for each number of IO requests (5 - 50)
//					to get the average seek times for FIFO, SSTF, SCAN and CSCAN
//					algorithms
//	generateRandomNum		Generates a random integer between 1 - 199 (inclusive)
//	sortTrackNumsArray		Sorts the track numbers in ascending order
//	FIFO				Computes the average seek time for a given sequence of tracks 
//					using FIFO algorithm
//	SSTF				Computes the average seek time for a given sequence of tracks 
//					using SSTF algorithm
//	SCAN				Computes the average seek time for a given sequence of tracks 
//					using SCAN algorithm
//	CSCAN				Computes the average seek time for a given sequence of tracks 
//					using CSCAN algorithm
/////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Required libraries */
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

/* Macros */
#define NUM_OF_ALGORITHMS 4		// The total number of algorithms
#define NUM_OF_IO 46			// The total number of possible numbers of IO requests (50 - 5 + 1 = 46)
#define MIN_TRACK_NUM 1			// The minimum track number
#define MAX_TRACK_NUM 199		// The maximum track number
#define STARTING_TRACK 100		// The starting track number

/* Global arrays */
double seekArray[NUM_OF_ALGORITHMS][NUM_OF_IO]; // Array to hold the average seek time of each number of IO requests for each algorithm
int trackNums[NUM_OF_IO + 4]; // Array to hold the sequence of track numbers
int tempTracksArray[NUM_OF_IO + 5]; // Array to hold and manipulate the track numbers
int randomNumbersArray[MAX_TRACK_NUM + 1];	// Array used for random number generation. The value of each element of the array indicates 
						// whether the corresponding index number has been used as a track number (0 = unused, 1 = used)

////////////////////////////////////////////////////////////////////////////////////////////
// int generateRandomNum ()
// Author: Raisaat Atifa Rashid
// Date: 28 April 2019
// Description:	Generates and returns a random integer between 1 - 199 (inclusive).
//		Gets the current time of the day to seed the random number generator.
//		Calls rand() function to generate a random integer between 1 -
//		199 (inclusive) and then returns the integer returned by rand().
//
// Parameters:
//     	generateRandomNum	O/P	int	the random integer generated by the function
////////////////////////////////////////////////////////////////////////////////////////////
int generateRandomNum ()
{
	struct timeval time; // Structure to hold the time of the day
	gettimeofday(&time, NULL); // Get the current time of the day
	srand(time.tv_sec * time.tv_usec); // Seed the random number generator

	// Call rand() to generate a random integer between 1 - 199 (inclusive) and return that integer
	return rand() % MAX_TRACK_NUM + MIN_TRACK_NUM;
}

////////////////////////////////////////////////////////////////////////////////////////////
// void sortTrackNumsArray(int numIO)
// Author: Raisaat Atifa Rashid
// Date: 28 April 2019
// Description:	Sorts the track numbers of the IO requests in ascending order. Copies 
//		the track numbers into the first numIO elements of a temporary array 
//		(tempTracksArray[]) and then uses the Bubble Sort algorithm to sort the 
//		first numIO elements of that temporary array.
//
// Parameters:
//     	numIO	I/P		int		The no. of IO requests
////////////////////////////////////////////////////////////////////////////////////////////
void sortTrackNumsArray(int numIO)
{
	/* Copy the  track numbers of the IO requests into the 
	first numIO elements of tempTracksArray[] */
	int i;
	for (i = 0; i < numIO; i++)
		tempTracksArray[i] = trackNums[i];

	// Assign the startng track number to the element of tempTracksArray[] that comes after the track numbers copied
	tempTracksArray[numIO] = STARTING_TRACK;

	/* Use Bubble Sort to sort tempTracksArray[] in ascending order */
	int j, temp;
	for (i = 0; i < numIO + 1; i++) // Loop through all the track numbers
	{
		for (j = i; j < numIO + 1; j++) // Loop through all the track numbers that come after the current track number
		{
			if (tempTracksArray[i] > tempTracksArray[j]) // If the current track number is greater than a track number which comes after the current track number
			{
				/* Swap the positions of the two track numbers */
				temp = tempTracksArray[i];
				tempTracksArray[i] = tempTracksArray[j];
				tempTracksArray[j] = temp;
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////
// void FIFO (int numIO)
// Author: Raisaat Atifa Rashid
// Date: 28 April 2019
// Description:	Uses FIFO algorithm to compute the average seek time for a given sequence
//		of track numbers. It loops through the array of track numbers (trackNums[])
//		and accumulates the seek times. The seek time is calculated by computing 
//		the absolute difference between the current track number and the next track 
//		number. It then divides the total seek time by the number of tracks (number 
//		of IO requests) to get the average seek time.
//
// Parameters:
//     	numIO		I/P		int		The no. of IO requests
////////////////////////////////////////////////////////////////////////////////////////////
void FIFO (int numIO)
{
	int currentTrack = STARTING_TRACK, // Variable to hold the current track number
		totalSeekTime = 0, // Variable to hold the sum all the seek times
		i; // For-loop counter

	for (i = 0; i < numIO; i++) // Loop through the track numbers
	{
		// Compute the absolute difference between the current track number and the track number 
		// of the next IO request, and add the result to totalSeekTime
		totalSeekTime += abs(currentTrack - trackNums[i]);

		// Go to the next track
		currentTrack = trackNums[i];
	}

	// Compute the average seek time by dividing the total seek time by the number of IO requests 
	// and add the result to the appropriate element of seekArray[]
	seekArray[0][numIO - 5] += ((double)totalSeekTime) / numIO;
}

////////////////////////////////////////////////////////////////////////////////////////////
// void SSTF(int numIO)
// Author: Raisaat Atifa Rashid
// Date: 28 April 2019
// Description:	Uses SSTF algorithm to compute the average seek time for a given sequence
//		of track numbers. It loops through the array of track numbers (trackNums[])
//		to find the track number that will give the shortest seek time from the
//		current track, and makes that track the next track. It accumulates the 
//		seek times which are calculated by computing the absolute difference between 
//		the next track number and the current track number. It then divides the 
//		total seek time by the number of tracks (number of IO requests) to get the 
//		average seek time.
//
// Parameters:
//     	numIO		I/P		int		The no. of IO requests
////////////////////////////////////////////////////////////////////////////////////////////
void SSTF(int numIO)
{
	int currentTrack = STARTING_TRACK, // Variable to hold the current track number
		totalSeekTime = 0, // Variable to hold the sum of all the seek times
		i; // For-loop counter

	/* Copy the  track numbers of the IO requests into the
	first numIO elements of tempTracksArray[] */
	for (i = 0; i < numIO; i++)
		tempTracksArray[i] = trackNums[i];

	for (i = 0; i < numIO; i++) // Loop through all the track numbers
	{
		int j, // For-loop counter
			shortestSeekTime = 200, // Variable to hold the shortest seek time
			bestIndex = 0; // Variable to hold the array index of the element containing the track with the shortest seek time

		/* Find the shortest seek time */
		for (j = 0; j < numIO; j++) // Loop through all the track numbers to find the next track that will give the shortest seek time
		{
			int seekTime = abs(currentTrack - tempTracksArray[j]); // Compute the seek time from the current track to each track

			if (seekTime < shortestSeekTime) // If the seek time is less than the shortest seek time
			{
				shortestSeekTime = seekTime; // Assign the seek time to shortestSeekTime
				bestIndex = j; // Assign the array index of the element containing the track with the shortest seek time to bestIndex
			}
		}

		// Add the shortest seek time to totalSeekTime
		totalSeekTime += shortestSeekTime;

		// Make the track that gives the shortest seek time the current track
		currentTrack = tempTracksArray[bestIndex];

		// Assign a large value to the element containing the track number that gives the shortest seek time so that the track does not get chosen ever again
		tempTracksArray[bestIndex] = 9999;
	}

	// Compute the average seek time by dividing the total seek time by the number of IO requests 
	// and add the result to the appropriate element of seekArray[]
	seekArray[1][numIO - 5] += ((double)totalSeekTime) / numIO;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// void SCAN (int numIO)
// Author: Raisaat Atifa Rashid
// Date: 28 April 2019
// Description:	Uses SCAN algorithm to compute the average seek time for a given sequence
//		of track numbers. It first sorts the track numbers in ascending order. It 
//		then loops through the tracks greater than the starting track in ascending 
//		order to go through all the tracks in the forward direction. When the last track 
//		in the forward is reached, it reverses its direction by looping through all 
//		the tracks that are less than the starting track in descending order. While
//		looping, it accumulates all the seek times which are calculated by computing
//		the absolute difference between the current track and the next track. It then 
//		divides the total seek time by the number of tracks (number of IO requests) 
//		to get the average seek time.
//
// Parameters:
//     	numIO		I/P		int		The no. of IO requests
//////////////////////////////////////////////////////////////////////////////////////////////////
void SCAN (int numIO)
{
	// Call sortTrackNums() to sort the track numbers in ascending order and put them in tempTracksArray[]
	sortTrackNumsArray(numIO);

	int currentTrack = STARTING_TRACK, // Variable to hold the current track number
		i, // For-loop counter
		startTrackLoc = 0, // Variable to hold the array index of the element containing the starting track
		totalSeekTime = 0; // Variable to hold the sum of all the seek times

	/* Find the location of the starting track in tempTracksArray[] */
	for (i = 0; i < numIO + 1; i++) // Loop through all the track numbers
	{
		if (tempTracksArray[i] == STARTING_TRACK) // If the track number is equal to the starting track number
		{
			startTrackLoc = i; // Assign the array index of the element containing the starting track number to startTrackLoc
			break; // Break from the for-loop
		}
	}

	/* Go through all the tracks in the forward direction beginning from the starting track until the last track in the forward 
	direction is reached (these are the track numbers greater than the starting track number in ascending order) */
	for (i = startTrackLoc + 1; i < numIO + 1; i++)
	{
		// Compute the absolute difference between the current track number and the 
		// next track number, and add the result to totalSeekTime
		totalSeekTime += abs(currentTrack - tempTracksArray[i]);

		// Go to the next track
		currentTrack = tempTracksArray[i];
	}

	/* Go through all the tracks in the reverse direction beginning from the current track until the last track in the reverse 
	direction is reached (these are the track numbers less than the starting track number in descending order) */
	for (i = startTrackLoc - 1; i >= 0; i--)
	{
		// Compute the absolute difference between the current track number and the 
		// next track number, and add the result to totalSeekTime
		totalSeekTime += abs(currentTrack - tempTracksArray[i]);

		// Go to the next track
		currentTrack = tempTracksArray[i];
	}

	// Compute the average seek time by dividing the total seek time by the number of IO requests 
	// and add the result to the appropriate element of seekArray[]
	seekArray[2][numIO - 5] += ((double)totalSeekTime) / numIO;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// void CSCAN (int numIO)
// Author: Raisaat Atifa Rashid
// Date: 28 April 2019
// Description:	Uses CSCAN algorithm to compute the average seek time for a given sequence
//		of track numbers. It first sorts the track numbers in ascending order. It 
//		then loops through the tracks greater than the starting track in ascending 
//		order to go through all the tracks in the forward direction. When the last track 
//		in the forward is reached, it goes to the first track and moves in the 
//		forward direction again by looping through all the tracks that are less 
//		than the starting track in ascending order. While looping, it accumulates 
//		all the seek times which are calculated by computing the absolute difference 
//		between the current track and the next track. It then divides the total seek 
//		time by the number of tracks (number of IO requests) to get the average seek 
//		time.
//
// Parameters:
//     	numIO		I/P		int		The no. of IO requests
/////////////////////////////////////////////////////////////////////////////////////////////////
void CSCAN (int numIO)
{
	// Call sortTrackNums() to sort the track numbers in ascending order and put them in tempTracksArray[]
	sortTrackNumsArray(numIO);

	int currentTrack = STARTING_TRACK, // Variable to hold the starting track number
		i, // For-loop counter
		startTrackLoc = 0, // Variable to hold the array index of the element containing the starting track number
		totalSeekTime = 0; // Variable to hold the sum of all the seek times

	/* Find the location of the starting track number in tempTracksArray[] */
	for (i = 0; i < numIO + 1; i++)
	{
		if (tempTracksArray[i] == STARTING_TRACK) // If the track number is equal to the starting track number
		{
			startTrackLoc = i; // Assign the array index of the element containing the starting track number to startTrackLoc
			break; // Break from the for-loop
		}
	}

	/* Go through all the tracks in the forward direction beginning from the starting track until the last track in the forward 
	direction is reached (these are the track numbers greater than the starting track number in ascending order) */
	for (i = startTrackLoc + 1; i < numIO + 1; i++)
	{
		// Compute the absolute difference between the current track number and the 
		// next track number, and add the result to totalSeekTime
		totalSeekTime += abs(currentTrack - tempTracksArray[i]);

		// Go to the next track
		currentTrack = tempTracksArray[i];
	}

	/* Loop through all the tracks in the forward direction beginning from the first track until the last 
	track in the forward direction is reached (these are the track numbers less than the starting track number in ascending order) */
	for (i = 0; i < startTrackLoc; i++)
	{
		// Compute the absolute difference between the current track number and the 
		// next track number, and add the result to totalSeekTime
		totalSeekTime += abs(currentTrack - tempTracksArray[i]);
		
		// Go to the next track
		currentTrack = tempTracksArray[i];
	}

	// Compute the average seek time by dividing the total seek time by the number of IO requests 
	// and add the result to the appropriate element of seekArray[]
	seekArray[3][numIO - 5] += ((double)totalSeekTime) / numIO;
}

////////////////////////////////////////////////////////////////////////////////////
// int main()
// Author: Raisaat Atifa Rashid
// Date: 28 April 2019
// Description: Loops through all the possible numbers of IO requests (5 - 50) and
//		runs 100 simulations for each number of IO requests. In each
//		simulation of each number of IO requests, it generates a sequence
//		of track numbers and calls FIFO(), SSTF(), SCAN(), CSCAN() to get
//		get the average seek times under FIFO, SSTF, SCAN and CSCAN algorithms
//		respectively. It then writes the results to the console and a text
//		file.
//
// Parameters:
//      main    	O/P     	int        	 status code
////////////////////////////////////////////////////////////////////////////////////
int main()
{
	/* Run 100 simulations for each number of IO requests (5 - 50) */
	int i;
	for (i = 5; i < NUM_OF_IO + 5; i++)
	{
		/* Run 100 simulations */
		int j;
		for (j = 0; j < 100; j++)
		{
			/* Assign 0 to elements 1 - 199 (inclusive) of randomNumbersArray[] to indicate 
			that the corresponding index numbers have not been used as track numbers for this simulation */
			int count;
			for (count = 1; count <= MAX_TRACK_NUM; count++)
				randomNumbersArray[count] = 0;
			
			/* Genrate random track numbers for the number of IO requests */
			for (count = 0; count < i; count++)
			{
				/* Loop until a unique random number is found */
				while (1)
				{
					// Call generateRandomNum() to generate a random number
					int num = generateRandomNum();

					if (!randomNumbersArray[num]) // If the random number has not been used yet, i.e. if the element in randomTracksArray[] representing the random number is 0
					{
						// Assign 1 to the element in randomTracksArray[] representing the random number to indicate that it has been used
						randomNumbersArray[num] = 1; 
						
						// Make the random number the track number of the current IO request
						trackNums[count] = num;
						
						// Break from the while loop
						break;
					}
				}
			}

			FIFO (i); // Call FIFO() to get the average seek time for the current number of IO requests using FIFO algorithm
			SSTF (i); // Call SSTF() to get the average seek time for the current number of IO requests using SSTF algorithm
			SCAN (i); // Call SCAN() to get the average seek time for the current number of IO requests using SCAN algorithm
			CSCAN (i); // Call CSCAN() to get the average seek time for the current number of IO requests using CSCAN algorithm
		}
	}

	// Create a file pointer
	FILE *fp;

	// Open file "Disk_Scheduling.txt" for writing
	fp = fopen("Disk_Scheduling.txt", "w");
	
	/* If the file could not be opened, i.e. if fp is NULL,
	print an error message to the console and exit from the program */
	if (fp == NULL)
	{
		printf("\nError opening file.\n");
		exit(-1);
	}

	// Print headings to the console
	printf ("%-17s%-11s%-11s%-11s%-11s\n", "No. of Tracks", "FIFO", "SSTF", "SCAN", "CSCAN");

	// Write the headings to the file
	fprintf(fp, "%-17s%-11s%-11s%-11s%-11s\n", "No. of Tracks", "FIFO", "SSTF", "SCAN", "CSCAN");

	/* Loop through the numbers of IO requests */
	for (i = 0; i < NUM_OF_IO; i++)
	{
		// Print to the console the current number of IO requests and the average seek time of each algorithm for the current number of IO requests
		printf("%-17d%-11.3f%-11.3f%-11.3f%-11.3f\n", i + 5, seekArray[0][i] / 100, seekArray[1][i] / 100, seekArray[2][i] / 100, seekArray[3][i] / 100);

		// Write to the file the current number of IO requests and the average seek time of each algorithm for the current number of IO requests
		fprintf(fp, "%-17d%-11.3f%-11.3f%-11.3f%-11.3f\n", i + 5, seekArray[0][i] / 100, seekArray[1][i] / 100, seekArray[2][i] / 100, seekArray[3][i] / 100);
	}
	
	// Close the file
	fclose(fp);

	// Exit the program
	return 0;
}
